\"\"\"Table definitions and SQL schemas for all backfillable tables.\"\"\"\n\nfrom typing import Dict, List, NamedTuple\n\n\nclass TableConfig(NamedTuple):\n    \"\"\"Configuration for a backfillable table.\"\"\"\n    name: str\n    description: str\n    source_tables: List[str]\n    create_sqls: List[str]  # SQL statements to create the table\n\n\n# Table registry - all available tables for backfilling\nTABLE_REGISTRY: Dict[str, TableConfig] = {\n    'address_diffs': TableConfig(\n        name='mainnet.int_address_diffs',\n        description='Aggregates diff data from balance, storage, nonce diffs and contracts',\n        source_tables=[\n            'canonical_execution_balance_diffs',\n            'canonical_execution_storage_diffs',\n            'canonical_execution_nonce_diffs',\n            'canonical_execution_contracts',\n            'canonical_execution_transaction',\n        ],\n        create_sqls=[\n            \"\"\"CREATE TABLE mainnet.int_address_diffs_local on cluster '{cluster}' (\n                `address` String COMMENT 'The address of the account' CODEC(ZSTD(1)),\n                `block_number` UInt32 COMMENT 'The block number of the diffs' CODEC(ZSTD(1)),\n                `tx_count` UInt32 COMMENT 'The number of transactions with diffs for this address in the block' CODEC(ZSTD(1)),\n                `last_tx_index` UInt32 COMMENT 'The last transaction index with diffs for this address in the block' CODEC(ZSTD(1))\n            ) ENGINE = ReplicatedMergeTree(\n                '/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}',\n                '{replica}'\n            ) PARTITION BY cityHash64(`address`) % 16\n            ORDER BY (address, block_number) COMMENT 'Table for accounts diffs data'\"\"\",\n            \n            \"\"\"CREATE TABLE mainnet.int_address_diffs ON CLUSTER '{cluster}' AS mainnet.int_address_diffs_local \n            ENGINE = Distributed('{cluster}', 'mainnet', int_address_diffs_local, cityHash64(`address`))\"\"\"\n        ]\n    ),\n    \n    'address_reads': TableConfig(\n        name='mainnet.int_address_reads',\n        description='Tracks read operations for addresses',\n        source_tables=[\n            'canonical_execution_balance_reads',\n            'canonical_execution_nonce_reads',\n            'canonical_execution_storage_reads',\n            'canonical_execution_transaction',\n        ],\n        create_sqls=[\n            \"\"\"CREATE TABLE mainnet.int_address_reads_local on cluster '{cluster}' (\n                `address` String COMMENT 'The address of the account' CODEC(ZSTD(1)),\n                `block_number` UInt32 COMMENT 'The block number of the reads' CODEC(ZSTD(1)),\n                `tx_count` UInt32 COMMENT 'The number of reads for this address in this block' CODEC(ZSTD(1)),\n                `last_tx_index` UInt32 COMMENT 'The last transaction index with reads for this address in the block' CODEC(ZSTD(1))\n            ) ENGINE = ReplicatedMergeTree(\n                '/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}',\n                '{replica}'\n            ) PARTITION BY cityHash64(`address`) % 16\n            ORDER BY (address, block_number) COMMENT 'Table for accounts reads data'\"\"\",\n            \n            \"\"\"CREATE TABLE mainnet.int_address_reads ON CLUSTER '{cluster}' AS mainnet.int_address_reads_local \n            ENGINE = Distributed('{cluster}', 'mainnet', int_address_reads_local, cityHash64(`address`))\"\"\"\n        ]\n    ),\n    \n    'address_first_access': TableConfig(\n        name='mainnet.int_address_first_access',\n        description='Tracks the first access block for each address',\n        source_tables=[\n            'canonical_execution_balance_diffs',\n            'canonical_execution_balance_reads',\n            'canonical_execution_contracts',\n            'canonical_execution_nonce_reads',\n            'canonical_execution_nonce_diffs',\n            'canonical_execution_storage_diffs',\n            'canonical_execution_storage_reads',\n        ],\n        create_sqls=[\n            \"\"\"CREATE TABLE mainnet.int_address_first_access_local on cluster '{cluster}' (\n                `address` String COMMENT 'The address of the account' CODEC(ZSTD(1)),\n                `block_number` UInt32 COMMENT 'The block number of the first access' CODEC(ZSTD(1)),\n                `version` UInt32 DEFAULT 4294967295 - block_number COMMENT 'Version for this address' CODEC(DoubleDelta, ZSTD(1))\n            ) ENGINE = ReplicatedReplacingMergeTree(\n                '/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}',\n                '{replica}',\n                `version`\n            ) PARTITION BY cityHash64(`address`) % 16\n            ORDER BY (address) COMMENT 'Table for accounts first access data'\"\"\",\n            \n            \"\"\"CREATE TABLE mainnet.int_address_first_access ON CLUSTER '{cluster}' AS mainnet.int_address_first_access_local \n            ENGINE = Distributed('{cluster}', 'mainnet', int_address_first_access_local, cityHash64(`address`))\"\"\"\n        ]\n    ),\n    \n    'address_last_access': TableConfig(\n        name='mainnet.int_address_last_access',\n        description='Tracks the last access block for each address',\n        source_tables=[\n            'canonical_execution_balance_diffs',\n            'canonical_execution_balance_reads',\n            'canonical_execution_contracts',\n            'canonical_execution_nonce_reads',\n            'canonical_execution_nonce_diffs',\n            'canonical_execution_storage_diffs',\n            'canonical_execution_storage_reads',\n        ],\n        create_sqls=[\n            \"\"\"CREATE TABLE mainnet.int_address_last_access_local on cluster '{cluster}' (\n                `address` String COMMENT 'The address of the account' CODEC(ZSTD(1)),\n                `block_number` UInt32 COMMENT 'The block number of the last access' CODEC(ZSTD(1)),\n                `is_deleted` Bool COMMENT 'Whether the account is deleted' CODEC(ZSTD(1))\n            ) ENGINE = ReplicatedReplacingMergeTree(\n                '/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}',\n                '{replica}',\n                `block_number`\n            ) PARTITION BY cityHash64(`address`) % 16\n            ORDER BY (address) COMMENT 'Table for accounts last access data'\"\"\",\n            \n            \"\"\"CREATE TABLE mainnet.int_address_last_access ON CLUSTER '{cluster}' AS mainnet.int_address_last_access_local \n            ENGINE = Distributed('{cluster}', 'mainnet', int_address_last_access_local, cityHash64(`address`))\"\"\"\n        ]\n    ),\n    \n    'address_storage_slot_first_access': TableConfig(\n        name='mainnet.int_address_storage_slot_first_access',\n        description='Tracks first access to storage slots',\n        source_tables=[\n            'canonical_execution_storage_diffs',\n            'canonical_execution_storage_reads',\n            'canonical_execution_transaction',\n        ],\n        create_sqls=[\n            \"\"\"CREATE TABLE mainnet.int_address_storage_slot_first_access_local on cluster '{cluster}' (\n                `address` String COMMENT 'The address of the account' CODEC(ZSTD(1)),\n                `slot_key` String COMMENT 'The slot key of the storage' CODEC(ZSTD(1)),\n                `block_number` UInt32 COMMENT 'The block number of the first access' CODEC(ZSTD(1)),\n                `value` String COMMENT 'The value of the storage' CODEC(ZSTD(1)),\n                `version` UInt32 DEFAULT 4294967295 - block_number COMMENT 'Version for this address + slot key' CODEC(Doub
